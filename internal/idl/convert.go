package idl

import (
	"errors"
	"fmt"
	"sort"
	"strings"

	"google.golang.org/protobuf/types/descriptorpb"

	"gopkg.microglot.org/compiler.go/internal/proto"
)

func URIToProtoFile(URI string) string {
	// this isn't strictly necessary, but it conforms better to how protoc treats paths, and thus it makes
	// the code we generate when we run protobuf plugins more similar to the output generated by the same
	// plugin via "protoc" (and thus it's easier for us to automatically test for compatible output).
	return strings.TrimLeft(URI, "/")
}

func (image *Image) ToFileDescriptorSet() (*descriptorpb.FileDescriptorSet, error) {
	converter := imageConverter{
		image: image,
	}
	return converter.convert()
}

type imageConverter struct {
	image *Image

	// SourceCodeInfo is accumulated here, as side-effects of the main conversion.
	p        *PathState
	location []*descriptorpb.SourceCodeInfo_Location
}

func (c *imageConverter) resetPathState() {
	c.p = &PathState{}
	c.location = []*descriptorpb.SourceCodeInfo_Location{}
}

func (c *imageConverter) maybeEmitLocation(commentBlock *proto.CommentBlock) {
	if commentBlock != nil {
		comment := strings.Join(commentBlock.Lines, "\n")

		location := descriptorpb.SourceCodeInfo_Location{
			Path:            c.p.CopyPath(),
			Span:            []int32{0, 0, 0, 0},
			LeadingComments: &comment,
			// TrailingComments
			// LeadingDetachedComments
		}
		c.location = append(c.location, &location)
	}
}

func (c *imageConverter) convert() (*descriptorpb.FileDescriptorSet, error) {
	files := make([]*descriptorpb.FileDescriptorProto, 0, len(c.image.Modules))
	for _, module := range c.image.Modules {
		file, err := c.fromModule(module)
		if err != nil {
			return nil, err
		}
		files = append(files, file)
	}
	files, err := c.topoSort(files)
	return &descriptorpb.FileDescriptorSet{
		File: files,
	}, err
}

func (c *imageConverter) topoSort(files []*descriptorpb.FileDescriptorProto) ([]*descriptorpb.FileDescriptorProto, error) {
	// Sort the incoming list as a best-effort attempt to keep the resulting
	// list consistently sorted when presented the same input.
	sort.SliceStable(files, func(i, j int) bool { return files[i].GetName() < files[j].GetName() })

	roots := make([]string, 0, len(files))
	sorted := make([]*descriptorpb.FileDescriptorProto, 0, len(files))
	completed := make(map[string]bool, len(files))
	nodeMap := make(map[string]*descriptorpb.FileDescriptorProto, len(files))
	dependsOn := make(map[string]map[string]bool)
	dependedOn := make(map[string]map[string]bool)
	for _, n := range files {
		nodeMap[n.GetName()] = n
		for _, dep := range n.Dependency {
			if _, ok := dependsOn[n.GetName()]; !ok {
				dependsOn[n.GetName()] = make(map[string]bool)
			}
			dependsOn[n.GetName()][dep] = true
			if _, ok := dependedOn[dep]; !ok {
				dependedOn[dep] = make(map[string]bool)
			}
			dependedOn[dep][n.GetName()] = true
		}
		if len(n.Dependency) < 1 {
			roots = append(roots, n.GetName())
		}
	}
	for len(roots) > 0 {
		current := roots[len(roots)-1]
		roots = roots[:len(roots)-1]
		node := nodeMap[current]
		if completed[node.GetName()] {
			continue
		}

		sorted = append(sorted, node)
		completed[node.GetName()] = true

		// We also sort the list of incoming edges for each node as this order
		// has an effect on the sorted output. For example, if multiple nodes
		// would become roots when some other node is processed then this
		// determines the order in which they are placed into the stack.
		nodeEdges := make([]string, 0, len(dependedOn[node.GetName()]))
		for k := range dependedOn[node.GetName()] {
			nodeEdges = append(nodeEdges, k)
		}
		sort.Strings(nodeEdges)
		for _, dep := range nodeEdges {
			delete(dependsOn[dep], node.GetName())
			if len(dependsOn[dep]) < 1 {
				roots = append(roots, dep)
			}
		}
	}
	// TODO 2024-03-01: Is it worth it to check for cycles and return an error
	// here? This seems like something that should happen outside of conversion
	// to proto. At the same time, I'm certain that microglot will have the same
	// guarantee of pre-sorted files.
	return sorted, nil
}

func mapFrom[F any, T any](c *imageConverter, in []*F, f func(*F) (T, error)) ([]T, error) {
	if in != nil {
		out := make([]T, 0, len(in))

		for _, element := range in {
			outElement, err := f(element)
			if err != nil {
				return nil, err
			}
			out = append(out, outElement)
			c.p.IncrementIndex()
		}

		return out, nil
	}
	return nil, nil
}

func GetProtobufAnnotation(as []*proto.AnnotationApplication, name string) *proto.Value {
	for _, annotation := range as {
		resolvedReference, ok := annotation.Annotation.Reference.(*proto.TypeSpecifier_Resolved)
		if !ok {
			continue
		}
		typeReference := resolvedReference.Resolved.Reference
		if typeReference.ModuleUID == 2 && typeReference.TypeUID == PROTOBUF_TYPE_UIDS[name] {
			return annotation.Value
		}
	}
	return nil
}

func getProtobufAnnotationString(as []*proto.AnnotationApplication, name string) *string {
	value := GetProtobufAnnotation(as, name)
	if value == nil {
		return nil
	}
	return &value.Kind.(*proto.Value_Text).Text.Value
}

func getProtobufAnnotationBool(as []*proto.AnnotationApplication, name string) *bool {
	value := GetProtobufAnnotation(as, name)
	if value == nil {
		return nil
	}
	return &value.Kind.(*proto.Value_Bool).Bool.Value
}

func GetPromotedSymbolTable(as []*proto.AnnotationApplication) map[string]string {
	promotedSymbolTable := make(map[string]string)
	nestedTypeInfo := GetProtobufAnnotation(as, "NestedTypeInfo")
	if nestedTypeInfo != nil {
		elements := nestedTypeInfo.Kind.(*proto.Value_Struct).Struct.Fields[0].Value.Kind.(*proto.Value_List).List.Elements
		for _, element := range elements {
			from := element.Kind.(*proto.Value_Struct).Struct.Fields[0].Value.Kind.(*proto.Value_Text).Text.Value
			to := element.Kind.(*proto.Value_Struct).Struct.Fields[1].Value.Kind.(*proto.Value_Text).Text.Value
			promotedSymbolTable[from] = to
		}
	}
	return promotedSymbolTable
}

func (c *imageConverter) lookupStruct(moduleUID uint64, structName string) *proto.Struct {
	for _, module := range c.image.Modules {
		if module.UID == moduleUID {
			for _, struct_ := range module.Structs {
				if struct_.Name.Name == structName {
					return struct_
				}
			}
		}
	}
	return nil
}

func (c *imageConverter) lookupEnum(moduleUID uint64, enumName string) *proto.Enum {
	for _, module := range c.image.Modules {
		if module.UID == moduleUID {
			for _, enum := range module.Enums {
				if enum.Name == enumName {
					return enum
				}
			}
		}
	}
	return nil
}

func (c *imageConverter) getNestedName(moduleUID uint64, name string) string {
	for _, module := range c.image.Modules {
		if module.UID == moduleUID {
			for _, struct_ := range module.Structs {
				for nestedName, promotedName := range GetPromotedSymbolTable(struct_.AnnotationApplications) {
					if promotedName == name {
						return fmt.Sprintf(".%s.%s", struct_.Name.Name, nestedName)
					}
				}
			}
			for _, enum := range module.Enums {
				for nestedName, promotedName := range GetPromotedSymbolTable(enum.AnnotationApplications) {
					if promotedName == name {
						return nestedName
					}
				}
			}
		}
	}
	return name
}

func (c *imageConverter) isPromotedType(moduleUID uint64, name string) bool {
	return c.getNestedName(moduleUID, name) != name
}

func (c *imageConverter) getQualifiedName(protobufPackage string, moduleUID uint64, name string) string {
	// TODO: 2024.02.01: Based on experimentation, it appears that protoc and
	//                   protocompile always produce fully qualified type names.
	//                   This behavior is relied on by some of the official Go
	//                   protobuf libraries. This method needs to be refactored
	//                   to handle fully qualified nested type references and
	//                   fully qualified map entry type references. It then
	//                   needs to be used anywhere a TypeName reference is
	//                   created.
	nestedName := c.getNestedName(moduleUID, name)
	if nestedName != name {
		return nestedName
	}
	if protobufPackage != "" {
		return fmt.Sprintf(".%s.%s", protobufPackage, name)
	}
	return fmt.Sprintf(".%s", name)
}

func (c *imageConverter) fromModule(module *proto.Module) (*descriptorpb.FileDescriptorProto, error) {
	// It is *NOT* a fatal error to attempt to convert a microglot Module that contains
	// stuff that cannot be represented in protobuf, e.g. SDKs. This conversion is allowed to be
	// lossy!

	c.resetPathState()

	var dependencies []string
	for _, import_ := range module.Imports {
		dependencies = append(dependencies, URIToProtoFile(import_.ImportedURI))
	}

	c.p.PushFieldNumber( /* MessageType */ 4)
	c.p.PushIndex()
	var messageTypes []*descriptorpb.DescriptorProto
	for _, struct_ := range module.Structs {
		if !c.isPromotedType(module.UID, struct_.Name.Name) {
			messageType, err := c.fromStruct(module, struct_)
			if err != nil {
				return nil, err
			}
			messageTypes = append(messageTypes, messageType)
			c.p.IncrementIndex()
		}
	}
	c.p.PopIndex()
	c.p.PopFieldNumber()

	var enumTypes []*descriptorpb.EnumDescriptorProto
	for _, enum := range module.Enums {
		if !c.isPromotedType(module.UID, enum.Name) {
			enumType, err := c.fromEnum(enum)
			if err != nil {
				return nil, err
			}
			enumTypes = append(enumTypes, enumType)
		}
	}

	var services []*descriptorpb.ServiceDescriptorProto
	for _, api := range module.APIs {
		service, err := c.fromAPI(api)
		if err != nil {
			return nil, err
		}
		services = append(services, service)
	}

	syntax := "proto3"
	name := URIToProtoFile(module.URI)

	var package_ *string = nil
	if module.ProtobufPackage != "" {
		package_ = &module.ProtobufPackage
	}

	return &descriptorpb.FileDescriptorProto{
		Name:       &name,
		Package:    package_,
		Dependency: dependencies,
		// PublicDependency
		// WeakDependency
		MessageType: messageTypes,
		EnumType:    enumTypes,
		Service:     services,
		// Extension

		Options: &descriptorpb.FileOptions{
			GoPackage: getProtobufAnnotationString(module.AnnotationApplications, "FileOptionsGoPackage"),
			// TODO 2023.12.30: remaining options
		},

		SourceCodeInfo: &descriptorpb.SourceCodeInfo{
			Location: c.location,
		},

		Syntax: &syntax,
		// Edition
	}, nil
}

func (c *imageConverter) synthesizeMapEntries(module *proto.Module, struct_ *proto.Struct) ([]*descriptorpb.DescriptorProto, error) {
	var synthetics []*descriptorpb.DescriptorProto
	for _, field := range struct_.Fields {
		resolved, ok := field.Type.Reference.(*proto.TypeSpecifier_Resolved)
		if !ok {
			return nil, errors.New("unexpected forward reference while converting descriptor to protobuf!")
		}
		if resolved.Resolved.Reference.ModuleUID == 0 {
			builtinTypeName, ok := GetBuiltinTypeNameFromUID(resolved.Resolved.Reference.TypeUID)
			if !ok {
				return nil, fmt.Errorf("unknown built-in type UID: %d", resolved.Resolved.Reference.TypeUID)
			}
			if builtinTypeName.Name == "Map" {
				// TODO 2024.01.16: this doesn't handle collisions at all, yet
				syntheticName := fmt.Sprintf("%sEntry", field.Name)
				true_ := true
				keyName := "key"
				var keyNumber int32 = 1
				_, keyType, keyTypeName, err := c.fromTypeSpecifier(resolved.Resolved.Parameters[0], nil)
				if err != nil {
					return nil, err
				}
				valueName := "value"
				var valueNumber int32 = 2
				_, valueType, valueTypeName, err := c.fromTypeSpecifier(resolved.Resolved.Parameters[1], nil)
				if err != nil {
					return nil, err
				}
				synthetics = append(synthetics, &descriptorpb.DescriptorProto{
					Name: &syntheticName,
					Field: []*descriptorpb.FieldDescriptorProto{
						&descriptorpb.FieldDescriptorProto{
							Name:     &keyName,
							Number:   &keyNumber,
							Type:     keyType,
							TypeName: keyTypeName,
						},
						&descriptorpb.FieldDescriptorProto{
							Name:     &valueName,
							Number:   &valueNumber,
							Type:     valueType,
							TypeName: valueTypeName,
						},
					},
					Options: &descriptorpb.MessageOptions{
						MapEntry: &true_,
					},
				})
			}
		}
	}
	return synthetics, nil
}

func (c *imageConverter) addMapEntryQualification(module *proto.Module, struct_ *proto.Struct, synthetics []*descriptorpb.DescriptorProto, fields []*descriptorpb.FieldDescriptorProto) {
	// Using unqualified names for synthetic map entry types appears to be valid
	// according to all the documentation I could find as of 2024-02-01.
	// However, the google.golang.org/protobuf/reflect/protoreflect library will
	// fail to interact with map entry references unless they are fully
	// qualified. I suspect that protoc and protocompile always render fully
	// qualified paths for these types. For compatibility, this sets the
	// TypeName for any synthetic map entry types to a fully qualified name.
	prefix := module.ProtobufPackage
	if prefix != "" && !strings.HasPrefix(prefix, ".") {
		prefix = "." + prefix
	}
	prefix = prefix + "." + struct_.Name.Name
	synth := make(map[string]bool, len(synthetics))
	for _, synthetic := range synthetics {
		synth[*synthetic.Name] = true
		synth[struct_.Name.Name+"."+*synthetic.Name] = true
		synth["."+struct_.Name.Name+"."+*synthetic.Name] = true
		synth[prefix+"."+*synthetic.Name] = true
	}

	for _, f := range fields {
		if f.TypeName != nil && synth[*f.TypeName] {
			tname := f.GetTypeName()
			tname = strings.TrimPrefix(tname, "."+module.ProtobufPackage)
			tname = strings.TrimPrefix(tname, module.ProtobufPackage)
			tname = strings.TrimPrefix(tname, "."+struct_.GetName().GetName()+".")
			tname = strings.TrimPrefix(tname, struct_.GetName().GetName()+".")
			tname = strings.TrimPrefix(tname, ".")
			*f.TypeName = prefix + "." + tname
		}
	}
}

func (c *imageConverter) fromStruct(module *proto.Module, struct_ *proto.Struct) (*descriptorpb.DescriptorProto, error) {
	nestedType, err := c.synthesizeMapEntries(module, struct_)
	if err != nil {
		return nil, err
	}

	c.p.PushFieldNumber( /* Field */ 2)
	c.p.PushIndex()
	fields, err := mapFrom(c, struct_.Fields, c.fromField)
	if err != nil {
		return nil, err
	}
	c.p.PopIndex()
	c.p.PopFieldNumber()

	oneofs, err := mapFrom(c, struct_.Unions, c.fromUnion)
	if err != nil {
		return nil, err
	}

	for _, field := range fields {
		if field.Proto3Optional != nil && *field.Proto3Optional {
			name := fmt.Sprintf("_%s", *field.Name)
			oneofs = append(oneofs, &descriptorpb.OneofDescriptorProto{
				Name: &name,
			})
			oneofIndex := (int32)(len(oneofs) - 1)
			field.OneofIndex = &oneofIndex
		}
	}

	var options *descriptorpb.MessageOptions
	if struct_.IsSynthetic {
		options = new(descriptorpb.MessageOptions)
		options.MapEntry = new(bool)
		*(options.MapEntry) = true
	}

	var enumType []*descriptorpb.EnumDescriptorProto
	for nestedName, promotedName := range GetPromotedSymbolTable(struct_.AnnotationApplications) {
		maybeStruct := c.lookupStruct(struct_.Reference.ModuleUID, promotedName)
		if maybeStruct == nil {
			maybeEnum := c.lookupEnum(struct_.Reference.ModuleUID, promotedName)
			if maybeEnum == nil {
				return nil, fmt.Errorf("unexpectedly missing promoted type named '%s'", promotedName)
			}
			maybeEnumType, err := c.fromEnum(maybeEnum)
			if err != nil {
				return nil, err
			}
			*maybeEnumType.Name = nestedName
			enumType = append(enumType, maybeEnumType)
		} else {
			maybeNestedType, err := c.fromStruct(module, maybeStruct)
			if err != nil {
				return nil, err
			}
			*maybeNestedType.Name = nestedName
			nestedType = append(nestedType, maybeNestedType)
		}
	}

	c.maybeEmitLocation(struct_.CommentBlock)
	c.addMapEntryQualification(module, struct_, nestedType, fields)

	name := new(string)
	*name = struct_.Name.Name
	// TODO: 2024.02.01: Audit the code for pointer passing like this. Replace
	//                   them with a helper that always generates a pointer to
	//                   a copy.
	return &descriptorpb.DescriptorProto{
		Name:       name,
		Field:      fields,
		OneofDecl:  oneofs,
		Options:    options,
		NestedType: nestedType,
		EnumType:   enumType,
		// Extension
		// ExtensionRange
		// ReservedRange
		// ReservedName
	}, nil
}

func (c *imageConverter) fromUnion(union *proto.Union) (*descriptorpb.OneofDescriptorProto, error) {
	return &descriptorpb.OneofDescriptorProto{
		Name: &union.Name,
		// Options
	}, nil
}

func (c *imageConverter) fromField(field *proto.Field) (*descriptorpb.FieldDescriptorProto, error) {
	number := int32(field.Reference.AttributeUID)
	label, type_, typeName, err := c.fromTypeSpecifier(field.Type, &field.Name)
	if err != nil {
		return nil, err
	}

	var oneofIndex *int32
	if field.UnionIndex != nil {
		oneofIndex = new(int32)
		*oneofIndex = (int32)(*field.UnionIndex)
	}

	proto3Optional := getProtobufAnnotationBool(field.AnnotationApplications, "Proto3Optional")
	if proto3Optional != nil && *proto3Optional == false {
		proto3Optional = nil
	}

	c.maybeEmitLocation(field.CommentBlock)
	return &descriptorpb.FieldDescriptorProto{
		Name:     &field.Name,
		Number:   &number,
		Label:    label,
		Type:     type_,
		TypeName: typeName,
		// Extendee
		// DefaultValue
		OneofIndex: oneofIndex,
		JsonName:   getProtobufAnnotationString(field.AnnotationApplications, "JsonName"),
		// Options
		Proto3Optional: proto3Optional,
	}, nil
}

func (c *imageConverter) fromTypeSpecifier(typeSpecifier *proto.TypeSpecifier, fieldName *string) (*descriptorpb.FieldDescriptorProto_Label, *descriptorpb.FieldDescriptorProto_Type, *string, error) {
	resolved, ok := typeSpecifier.Reference.(*proto.TypeSpecifier_Resolved)
	if !ok {
		return nil, nil, nil, errors.New("unexpected forward reference while converting descriptor to protobuf!")
	}

	label, type_, typeName, err := c.fromResolvedReference(resolved.Resolved, fieldName)
	if err != nil {
		return nil, nil, nil, err
	}
	return label, type_, typeName, nil
}

func (c *imageConverter) fromResolvedReference(resolvedReference *proto.ResolvedReference, fieldName *string) (*descriptorpb.FieldDescriptorProto_Label, *descriptorpb.FieldDescriptorProto_Type, *string, error) {

	// moduleUID 0 is for built-in types
	if resolvedReference.Reference.ModuleUID == 0 {
		builtinTypeName, ok := GetBuiltinTypeNameFromUID(resolvedReference.Reference.TypeUID)
		if !ok {
			return nil, nil, nil, fmt.Errorf("unknown built-in type UID: %d", resolvedReference.Reference.TypeUID)
		}

		// TODO 2023.11.09: respect $(Protobuf.FieldType())

		switch builtinTypeName.Name {
		case "Bool":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_BOOL
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Text":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_STRING
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Data":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_BYTES
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Int8":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT32
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Int16":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT32
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Int32":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT32
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Int64":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT64
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "UInt8":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT32
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "UInt16":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT32
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "UInt32":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT32
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "UInt64":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT64
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Float32":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_FLOAT
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "Float64":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_DOUBLE
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, &type_, nil, nil
		case "List":
			_, type_, typeName, err := c.fromTypeSpecifier(resolvedReference.Parameters[0], nil)
			if err != nil {
				return nil, nil, nil, err
			}
			label := descriptorpb.FieldDescriptorProto_LABEL_REPEATED
			return &label, type_, typeName, nil
		case "Presence":
			_, type_, typeName, err := c.fromTypeSpecifier(resolvedReference.Parameters[0], nil)
			if err != nil {
				return nil, nil, nil, err
			}
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, type_, typeName, nil
		case "Map":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_MESSAGE
			typeName := fmt.Sprintf("%sEntry", *fieldName)
			label := descriptorpb.FieldDescriptorProto_LABEL_REPEATED
			return &label, &type_, &typeName, nil
		default:
			return nil, nil, nil, fmt.Errorf("built-in type %v doesn't convert to protobuf", builtinTypeName)
		}
	}

	for _, module := range c.image.Modules {
		if module.UID == resolvedReference.Reference.ModuleUID {
			for _, struct_ := range module.Structs {
				if struct_.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					type_ := descriptorpb.FieldDescriptorProto_TYPE_MESSAGE
					typeName := c.getQualifiedName(module.ProtobufPackage, struct_.Reference.ModuleUID, struct_.Name.Name)
					label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
					return &label, &type_, &typeName, nil
				}
			}
			for _, enum := range module.Enums {
				if enum.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					type_ := descriptorpb.FieldDescriptorProto_TYPE_ENUM
					typeName := c.getQualifiedName(module.ProtobufPackage, enum.Reference.ModuleUID, enum.Name)
					label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
					return &label, &type_, &typeName, nil
				}
			}
			for _, api := range module.APIs {
				if api.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use an API (%s) as a protobuf type", api.Name)
				}
			}
			for _, sdk := range module.SDKs {
				if sdk.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use an SDK (%s) as a protobuf type", sdk.Name)
				}
			}
			for _, annotation := range module.Annotations {
				if annotation.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use an Annotation (%s) as a protobuf type", annotation.Name)
				}
			}
			for _, constant := range module.Constants {
				if constant.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use a Constant (%s) as a protobuf type", constant.Name)
				}
			}
		}
	}

	return nil, nil, nil, fmt.Errorf("linked type with moduleUID=%d and typeUID=%d wasn't found in the image!", resolvedReference.Reference.ModuleUID, resolvedReference.Reference.TypeUID)
}

func (c *imageConverter) fromEnum(enum *proto.Enum) (*descriptorpb.EnumDescriptorProto, error) {
	values, err := mapFrom(c, enum.Enumerants, c.fromEnumerant)
	if err != nil {
		return nil, err
	}

	return &descriptorpb.EnumDescriptorProto{
		Name:  &enum.Name,
		Value: values,
		// Options
		// ReservedRange
		// ReservedName
	}, nil
}

func (c *imageConverter) fromEnumerant(enumerant *proto.Enumerant) (*descriptorpb.EnumValueDescriptorProto, error) {
	number := (int32)(enumerant.Reference.AttributeUID)
	return &descriptorpb.EnumValueDescriptorProto{
		Name:   &enumerant.Name,
		Number: &number,
		// Options
	}, nil
}

func (c *imageConverter) fromAPI(api *proto.API) (*descriptorpb.ServiceDescriptorProto, error) {
	methods, err := mapFrom(c, api.Methods, c.fromAPIMethod)
	if err != nil {
		return nil, err
	}

	return &descriptorpb.ServiceDescriptorProto{
		Name:   &api.Name.Name,
		Method: methods,
		// Options
	}, nil
}

func (c *imageConverter) fromAPIMethod(apiMethod *proto.APIMethod) (*descriptorpb.MethodDescriptorProto, error) {
	_, _, inputTypeName, err := c.fromTypeSpecifier(apiMethod.Input, nil)
	if err != nil {
		return nil, err
	}
	_, _, outputTypeName, err := c.fromTypeSpecifier(apiMethod.Output, nil)
	if err != nil {
		return nil, err
	}

	return &descriptorpb.MethodDescriptorProto{
		Name:       &apiMethod.Name,
		InputType:  inputTypeName,
		OutputType: outputTypeName,
		// Options:
		// ClientStreaming:
		// ServerStreaming:
	}, nil
}
