package idl

import (
	"errors"
	"fmt"

	"google.golang.org/protobuf/types/descriptorpb"

	"gopkg.microglot.org/compiler.go/internal/proto"
)

func (image *Image) ToFileDescriptorSet() (*descriptorpb.FileDescriptorSet, error) {
	converter := imageConverter{
		image: image,
	}
	return converter.convert()
}

type imageConverter struct {
	image *Image
}

func (c *imageConverter) convert() (*descriptorpb.FileDescriptorSet, error) {
	files := make([]*descriptorpb.FileDescriptorProto, 0, len(c.image.Modules))
	for _, module := range c.image.Modules {
		file, err := c.fromModule(module)
		if err != nil {
			return nil, err
		}
		files = append(files, file)
	}
	return &descriptorpb.FileDescriptorSet{
		File: files,
	}, nil
}

func mapFrom[F any, T any](in []*F, f func(*F) (T, error)) ([]T, error) {
	if in != nil {
		out := make([]T, 0, len(in))

		for _, element := range in {
			outElement, err := f(element)
			if err != nil {
				return nil, err
			}
			out = append(out, outElement)
		}

		return out, nil
	}
	return nil, nil
}

func GetProtobufAnnotation(as []*proto.AnnotationApplication, name string) *proto.Value {
	for _, annotation := range as {
		typeReference := *(annotation.Annotation.Reference.(*proto.TypeSpecifier_Resolved).Resolved.Reference)
		if typeReference.ModuleUID == 1 && typeReference.TypeUID == PROTOBUF_TYPE_UIDS[name] {
			return annotation.Value
		}
	}
	return nil
}

func (c *imageConverter) fromModule(module *proto.Module) (*descriptorpb.FileDescriptorProto, error) {
	// TODO 2023.11.03: is it a fatal error to attempt to convert a microglot Module that contains
	// stuff that cannot be represented in protobuf, e.g. SDKs? Or is this conversion allowed to be
	// lossy?

	var dependencies []string
	for _, import_ := range module.Imports {
		dependencies = append(dependencies, import_.ImportedURI)
	}

	messageTypes, err := mapFrom(module.Structs, c.fromStruct)
	if err != nil {
		return nil, err
	}

	enumTypes, err := mapFrom(module.Enums, c.fromEnum)
	if err != nil {
		return nil, err
	}

	// TODO 2023.11.03: this is a HUGE HACK. I want to be able to `protoc --descriptor_set_in=... --go_out=...`
	// as a way to diff the code generated by a .proto directly from protoc vs. one that has been converted
	// to and from a microglot descriptor... but the conversion is currently dropping "options", and that's
	// a big hairball; my shortcut is to just hard-code a goPackage here, for now.
	goPackage := "gopkg.microglot.org/compiler.go/internal/proto"

	syntax := "proto3"

	return &descriptorpb.FileDescriptorProto{
		Name:       &module.URI,
		Package:    &module.ProtobufPackage,
		Dependency: dependencies,
		// PublicDependency
		// WeakDependency
		MessageType: messageTypes,
		EnumType:    enumTypes,
		// Service
		// Extension

		// TODO 2023.11.03: as above, this is a big hard-coded hack that needs to be removed!
		Options: &descriptorpb.FileOptions{
			GoPackage: &goPackage,
		},

		// SourceCodeInfo
		Syntax: &syntax,
		// Edition
	}, nil
}

func (c *imageConverter) fromStruct(struct_ *proto.Struct) (*descriptorpb.DescriptorProto, error) {
	fields, err := mapFrom(struct_.Fields, c.fromField)
	if err != nil {
		return nil, err
	}

	oneofs, err := mapFrom(struct_.Unions, c.fromUnion)
	if err != nil {
		return nil, err
	}
	for _, field := range fields {
		// if proto3Optional
		if field.Proto3Optional != nil && *field.Proto3Optional {
			// TODO 2023.11.12: there's presumably a naming convention for these synthetic oneofs.
			name := "synthetic"
			oneofs = append(oneofs, &descriptorpb.OneofDescriptorProto{
				Name: &name,
			})
			oneofIndex := (int32)(len(oneofs) - 1)
			field.OneofIndex = &oneofIndex
		}
	}

	var options *descriptorpb.MessageOptions
	if struct_.IsSynthetic {
		options = new(descriptorpb.MessageOptions)
		options.MapEntry = new(bool)
		*(options.MapEntry) = true
	}

	return &descriptorpb.DescriptorProto{
		Name:      &struct_.Name.Name,
		Field:     fields,
		OneofDecl: oneofs,
		Options:   options,
		// Extension
		// NestedType
		// EnumType
		// ExtensionRange
		// ReservedRange
		// ReservedName
	}, nil
}

func (c *imageConverter) fromUnion(union *proto.Union) (*descriptorpb.OneofDescriptorProto, error) {
	return &descriptorpb.OneofDescriptorProto{
		Name: &union.Name,
		// Options
	}, nil
}

func (c *imageConverter) fromField(field *proto.Field) (*descriptorpb.FieldDescriptorProto, error) {
	number := (int32)(field.Reference.AttributeUID)

	label, type_, typeName, err := c.fromTypeSpecifier(field.Type)
	if err != nil {
		return nil, err
	}

	var oneofIndex *int32
	if field.UnionIndex != nil {
		oneofIndex = new(int32)
		*oneofIndex = (int32)(*field.UnionIndex)
	}

	var proto3Optional *bool
	if label != nil && *label == descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL {
		proto3Optional = new(bool)
		*proto3Optional = true
	}

	return &descriptorpb.FieldDescriptorProto{
		Name:     &field.Name,
		Number:   &number,
		Label:    label,
		Type:     type_,
		TypeName: typeName,
		// Extendee
		// DefaultValue
		OneofIndex: oneofIndex,
		// JsonName
		// Options

		Proto3Optional: proto3Optional,
	}, nil
}

func (c *imageConverter) fromTypeSpecifier(typeSpecifier *proto.TypeSpecifier) (*descriptorpb.FieldDescriptorProto_Label, *descriptorpb.FieldDescriptorProto_Type, *string, error) {
	resolved, ok := typeSpecifier.Reference.(*proto.TypeSpecifier_Resolved)
	if !ok {
		return nil, nil, nil, errors.New("unexpected forward reference while converting descriptor to protobuf!")
	}

	label, type_, typeName, err := c.fromResolvedReference(resolved.Resolved)
	if err != nil {
		return nil, nil, nil, err
	}
	return label, type_, typeName, nil
}

func (c *imageConverter) fromResolvedReference(resolvedReference *proto.ResolvedReference) (*descriptorpb.FieldDescriptorProto_Label, *descriptorpb.FieldDescriptorProto_Type, *string, error) {

	// moduleUID 0 is for built-in types
	if resolvedReference.Reference.ModuleUID == 0 {
		builtinTypeName, ok := GetBuiltinTypeNameFromUID(resolvedReference.Reference.TypeUID)
		if !ok {
			return nil, nil, nil, fmt.Errorf("unknown built-in type UID: %d\n", resolvedReference.Reference.TypeUID)
		}

		// TODO 2023.11.09: respect $(Protobuf.FieldType())

		switch builtinTypeName {
		case "Bool":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_BOOL
			return nil, &type_, nil, nil
		case "Text":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_STRING
			return nil, &type_, nil, nil
		case "Data":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_BYTES
			return nil, &type_, nil, nil
		case "Int8":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT32
			return nil, &type_, nil, nil
		case "Int16":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT32
			return nil, &type_, nil, nil
		case "Int32":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT32
			return nil, &type_, nil, nil
		case "Int64":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_INT64
			return nil, &type_, nil, nil
		case "UInt8":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT32
			return nil, &type_, nil, nil
		case "UInt16":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT32
			return nil, &type_, nil, nil
		case "UInt32":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT32
			return nil, &type_, nil, nil
		case "UInt64":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_UINT64
			return nil, &type_, nil, nil
		case "Float32":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_FLOAT
			return nil, &type_, nil, nil
		case "Float64":
			type_ := descriptorpb.FieldDescriptorProto_TYPE_DOUBLE
			return nil, &type_, nil, nil
		case "List":
			_, type_, typeName, err := c.fromTypeSpecifier(resolvedReference.Parameters[0])
			if err != nil {
				return nil, nil, nil, err
			}
			label := descriptorpb.FieldDescriptorProto_LABEL_REPEATED
			return &label, type_, typeName, nil
		case "Presence":
			_, type_, typeName, err := c.fromTypeSpecifier(resolvedReference.Parameters[0])
			if err != nil {
				return nil, nil, nil, err
			}
			label := descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL
			return &label, type_, typeName, nil
		default:
			return nil, nil, nil, fmt.Errorf("built-in type %s doesn't convert to protobuf", builtinTypeName)
		}
	}

	for _, module := range c.image.Modules {
		if module.UID == resolvedReference.Reference.ModuleUID {
			for _, struct_ := range module.Structs {
				if struct_.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					// TODO 2023.11.09: convert to fully-qualified type name
					type_ := descriptorpb.FieldDescriptorProto_TYPE_MESSAGE
					return nil, &type_, &struct_.Name.Name, nil
				}
			}
			for _, enum := range module.Enums {
				if enum.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					// TODO 2023.11.09: convert to fully-qualified type name
					type_ := descriptorpb.FieldDescriptorProto_TYPE_ENUM
					return nil, &type_, &enum.Name, nil
				}
			}
			for _, api := range module.APIs {
				if api.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use an API (%s) as a protobuf type", api.Name)
				}
			}
			for _, sdk := range module.SDKs {
				if sdk.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use an SDK (%s) as a protobuf type", sdk.Name)
				}
			}
			for _, annotation := range module.Annotations {
				if annotation.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use an Annotation (%s) as a protobuf type", annotation.Name)
				}
			}
			for _, constant := range module.Constants {
				if constant.Reference.TypeUID == resolvedReference.Reference.TypeUID {
					return nil, nil, nil, fmt.Errorf("can't use a Constant (%s) as a protobuf type", constant.Name)
				}
			}
		}
	}

	return nil, nil, nil, fmt.Errorf("linked type with moduleUID=%d and typeUID=%d wasn't found in the image!", resolvedReference.Reference.ModuleUID, resolvedReference.Reference.TypeUID)
}

func (c *imageConverter) fromEnum(enum *proto.Enum) (*descriptorpb.EnumDescriptorProto, error) {
	values, err := mapFrom(enum.Enumerants, c.fromEnumerant)
	if err != nil {
		return nil, err
	}

	return &descriptorpb.EnumDescriptorProto{
		Name:  &enum.Name,
		Value: values,
		// Options
		// ReservedRange
		// ReservedName
	}, nil
}

func (c *imageConverter) fromEnumerant(enumerant *proto.Enumerant) (*descriptorpb.EnumValueDescriptorProto, error) {
	number := (int32)(enumerant.Reference.AttributeUID)
	return &descriptorpb.EnumValueDescriptorProto{
		Name:   &enumerant.Name,
		Number: &number,
		// Options
	}, nil
}
