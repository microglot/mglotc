package mgdl_gen_go

import (
	"bytes"
	"fmt"
	"go/token"
	"path"
	"strings"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/types/pluginpb"

	"gopkg.microglot.org/compiler.go/internal/idl"
	"gopkg.microglot.org/compiler.go/internal/proto"
	"gopkg.microglot.org/compiler.go/internal/target"
)

// the generatedFile struct and its interface are very closely derived from protobuf/compiler/protogen;
// those types are unfortunately too tightly tied to protobuf's plugin system to be reused here.
type generatedFile struct {
	filename string
	buf      bytes.Buffer
}

func (g *generatedFile) P(v ...interface{}) {
	for _, x := range v {
		switch x := x.(type) {
		default:
			fmt.Fprint(&g.buf, x)
		}
	}
	fmt.Fprintln(&g.buf)
}

// generate a golang type name from a proto.TypeSpecifier
func genType(image *idl.Image, t *proto.TypeSpecifier) string {
	resolved := t.Reference.(*proto.TypeSpecifier_Resolved).Resolved
	kind, declaration := image.Lookup(resolved.Reference)
	switch kind {
	case idl.TypeKindPrimitive:
		switch declaration.(*proto.Struct).Name.Name {
		case "Bool":
			return "bool"
		case "Text":
			return "string"
		case "Int8":
			return "int8"
		case "Int16":
			return "int16"
		case "Int32":
			return "int32"
		case "Int64":
			return "int64"
		case "UInt8":
			return "uint8"
		case "UInt16":
			return "uint16"
		case "UInt32":
			return "uint32"
		case "UInt64":
			return "uint64"
		case "Float32":
			return "float32"
		case "Float64":
			return "float64"
		default:
			// type checking should prevent this from ever happening
			panic("unknown primitive type in mgdl-gen-go")
		}
	case idl.TypeKindStruct:
		return "*" + declaration.(*proto.Struct).Name.Name
	case idl.TypeKindAPI:
		// name of the server interface generated by protoc_gen_go_grpc
		return fmt.Sprintf("%sServer", declaration.(*proto.API).Name.Name)
	case idl.TypeKindSDK:
		// name of the SDK as specified in the .mgdl
		return declaration.(*proto.SDK).Name.Name
	case idl.TypeKindVirtual:
		switch declaration.(*proto.Struct).Name.Name {
		case "List":
			return fmt.Sprintf("[]%s", genType(image, resolved.Parameters[0]))
		case "Presence":
			return fmt.Sprintf("*%s", genType(image, resolved.Parameters[0]))
		case "Map":
			return fmt.Sprintf("map[%s]%s", genType(image, resolved.Parameters[0]), genType(image, resolved.Parameters[1]))
		default:
			panic("unsupported virtual type in mgdl-gen-go")
		}
	default:
		// TODO 2024.01.02: data, enum, annotation
		panic("unsupported type in mgdl-gen-go")
	}
}

// generate a golang literal from a proto.Value
func genLiteral(value *proto.Value) string {
	switch v := value.Kind.(type) {
	case *proto.Value_Bool:
		return fmt.Sprintf("%#v", v.Bool.Value)
	case *proto.Value_Text:
		return fmt.Sprintf("%#v", v.Text.Value)
	case *proto.Value_Int8:
		return fmt.Sprintf("%#v", v.Int8.Value)
	case *proto.Value_Int16:
		return fmt.Sprintf("%#v", v.Int16.Value)
	case *proto.Value_Int32:
		return fmt.Sprintf("%#v", v.Int32.Value)
	case *proto.Value_Int64:
		return fmt.Sprintf("%#v", v.Int64.Value)
	case *proto.Value_UInt8:
		return fmt.Sprintf("%#v", v.UInt8.Value)
	case *proto.Value_UInt16:
		return fmt.Sprintf("%#v", v.UInt16.Value)
	case *proto.Value_UInt32:
		return fmt.Sprintf("%#v", v.UInt32.Value)
	case *proto.Value_UInt64:
		return fmt.Sprintf("%#v", v.UInt64.Value)
	case *proto.Value_Float32:
		return fmt.Sprintf("%#v", v.Float32.Value)
	case *proto.Value_Float64:
		return fmt.Sprintf("%#v", v.Float64.Value)
	default:
		// type checking should prevent this from ever happening
		panic("unsupported value kind in mgdl-gen-go")
	}
}

type pathMode string

const (
	pathModeImport   pathMode = "IMPORT"
	pathModeRelative pathMode = "RELATIVE"
)
const (
	paramRelative = "paths=source_relative"
	paramImport   = "paths=import"
	paramModule   = "module="
)

func Embed(parameters string, image *idl.Image, targets []string) ([]*pluginpb.CodeGeneratorResponse_File, error) {
	pathmode := pathModeImport
	var modulePrefix string
	if parameters == paramRelative {
		pathmode = pathModeRelative
	}
	if strings.HasPrefix(parameters, paramModule) {
		pathmode = pathModeImport
		modulePrefix = strings.TrimPrefix(parameters, paramModule)
	}
	// the use of CodeGeneratorResponse_File is just for short-term convenience, here; don't hesitate to
	// switch it out for something better.
	files := []*pluginpb.CodeGeneratorResponse_File{}
	for _, tgt := range targets {
		targetURI := target.Normalize(tgt)
		for _, module := range image.Modules {
			if module.URI == targetURI {
				// TODO 2024.01.03: what about package names in .mgdl directly? Currently this
				//  forces the $(Protobuf.FileOptionsGoPackage()) annotation, which is definitely
				//  weird when the source file is .mgdl
				// TODO 2024.01.03: support -M flag, not only the go package
				packageValue := idl.GetProtobufAnnotation(module.AnnotationApplications, "FileOptionsGoPackage")
				if packageValue == nil {
					return nil, fmt.Errorf("unable to determine Go import path for %q. Please add a $(Protobuf.FileOptionsGoPackage()) annotation.\n", module.URI)
				}
				s := packageValue.Kind.(*proto.Value_Text).Text.Value
				var packageName string
				var packagePath string
				if i := strings.Index(s, ";"); i >= 0 {
					packageName = GoSanitized(s[i+1:])
					packagePath = s[0:i]
				} else {
					packageName = GoSanitized(s)
					packagePath = s
				}

				var filename string
				switch pathmode {
				case pathModeRelative:
					prefix := module.URI
					prefix = removeProtoExt(prefix)
					filename = prefix + ".mgdl.go"
				case pathModeImport:
					file := path.Base(module.URI)
					file = removeProtoExt(file)
					filename = path.Join(packagePath, file) + ".mgdl.go"
					if modulePrefix != "" {
						filename = strings.TrimPrefix(filename, modulePrefix)
					}
				}

				g := &generatedFile{
					filename: filename,
				}

				g.P("// Code generated by mgdl-gen-go. DO NOT EDIT.")
				g.P()
				g.P("package ", packageName)
				g.P()

				// emit constants
				for _, constant := range module.Constants {
					g.P("// const ", constant.Name)
					g.P("const ", constant.Name, " ", genType(image, constant.Type), " = ", genLiteral(constant.Value))
					g.P()
				}

				// emit sdks
				for _, sdk := range module.SDKs {
					ifName := sdk.Name.Name
					g.P("// type ", ifName, " is the interface for ", sdk.Name.Name, "SDK.")
					g.P("type ", ifName, " interface {")
					for _, ext := range sdk.Extends {
						g.P("    ", genType(image, ext))
					}
					for _, method := range sdk.Methods {
						arguments := "ctx context.Context"
						for _, input := range method.Input {
							arguments += ", "
							arguments += input.Name + " "
							arguments += genType(image, input.Type)
						}
						rtype := ""
						if method.Output != nil {
							rtype = genType(image, method.Output)
						}
						if !method.NoThrows {
							if rtype == "" {
								rtype = "error"
							} else {
								rtype = "(" + rtype + ", error" + ")"
							}
						}

						g.P("    ", method.Name, "(", arguments, ") ", rtype)
					}
					g.P("}")
				}

				content := g.buf.String()
				files = append(files, &pluginpb.CodeGeneratorResponse_File{
					Name:    &g.filename,
					Content: &content,
				})
			}
		}
	}
	return files, nil
}

func removeProtoExt(s string) string {
	if ext := path.Ext(s); ext == ".proto" || ext == ".protodevel" {
		return s[:len(s)-len(ext)]
	}
	return s
}

// COPY/PASTE FROM google.golang.org/protobuf/internal/strs!
// GoSanitized converts a string to a valid Go identifier.
func GoSanitized(s string) string {
	// Sanitize the input to the set of valid characters,
	// which must be '_' or be in the Unicode L or N categories.
	s = strings.Map(func(r rune) rune {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			return r
		}
		return '_'
	}, s)

	// Prepend '_' in the event of a Go keyword conflict or if
	// the identifier is invalid (does not start in the Unicode L category).
	r, _ := utf8.DecodeRuneInString(s)
	if token.Lookup(s).IsKeyword() || !unicode.IsLetter(r) {
		return "_" + s
	}
	return s
}
